.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Import::Into 3"
.TH Import::Into 3 "2013-03-26" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Import::Into \- import packages into other packages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  package My::MultiExporter;
\&
\&  use Import::Into;
\&
\&  use Thing1 ();
\&  use Thing2 ();
\&
\&  sub import {
\&    my $target = caller;
\&    Thing1\->import::into($target);
\&    Thing2\->import::into($target, qw(import arguments));
\&  }
.Ve
.PP
Note: you don't need to do anything more clever than this provided you
document that people wanting to re-export your module should also be using
Import::Into. In fact, for a single module you can simply do:
.PP
.Vb 4
\&  sub import {
\&    ...
\&    Thing1\->import::into(scalar caller);
\&  }
.Ve
.PP
Notably, this works:
.PP
.Vb 1
\&  use base qw(Exporter);
\&
\&  sub import {
\&    shift\->export_to_level(1);
\&    Thing1\->import::into(scalar caller);
\&  }
.Ve
.PP
Note 2: You do \fBnot\fR need to do anything to Thing1 to be able to call
\&\f(CW\*(C`import::into\*(C'\fR on it. This is a global method, and is callable on any
package (and in fact on any object as well, although it's rarer that you'd
want to do that).
.PP
Finally, we also provide an \f(CW\*(C`unimport::out_of\*(C'\fR to allow the exporting of the
effect of \f(CW\*(C`no\*(C'\fR:
.PP
.Vb 4
\&  # unimport::out_of was added in 1.1.0 (1.001000)
\&  sub unimport {
\&    Moose\->unimport::out_of(scalar caller); # no MyThing == no Moose
\&  }
.Ve
.PP
If how and why this all works is of interest to you, please read on to the
description immediately below.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Writing exporters is a pain. Some use Exporter, some use Sub::Exporter,
some use Moose::Exporter, some use Exporter::Declare ... and some things
are pragmas.
.PP
If you want to re-export other things, you have to know which is which.
Exporter subclasses provide export_to_level, but if they overrode their
import method all bets are off. Sub::Exporter provides an into parameter
but figuring out something used it isn't trivial. Pragmas need to have
their \f(CW\*(C`import\*(C'\fR method called directly since they affect the current unit of
compilation.
.PP
It's ... annoying.
.PP
However, there is an approach that actually works for all of these types.
.PP
.Vb 1
\&  eval "package $target; use $thing;"
.Ve
.PP
will work for anything checking caller, which is everything except pragmas.
But it doesn't work for pragmas \- pragmas need:
.PP
.Vb 1
\&  $thing\->import;
.Ve
.PP
because they're designed to affect the code currently being compiled \- so
within an eval, that's the scope of the eval itself, not the module that
just \f(CW\*(C`use\*(C'\fRd you \- so
.PP
.Vb 3
\&  sub import {
\&    eval "use strict;"
\&  }
.Ve
.PP
doesn't do what you wanted, but
.PP
.Vb 3
\&  sub import {
\&    strict\->import;
\&  }
.Ve
.PP
will apply strict to the calling file correctly.
.PP
Of course, now you have two new problems \- first, that you still need to
know if something's a pragma, and second that you can't use either of
these approaches alone on something like Moose or Moo that's both
an exporter and a pragma.
.PP
So, the complete solution is:
.PP
.Vb 2
\&  my $sub = eval "package $target; sub { shift\->import(\e@_) }";
\&  $sub\->($thing, @import_args);
.Ve
.PP
which means that import is called from the right place for pragmas to take
effect, and from the right package for caller checking to work \- and so
behaves correctly for all types of exporter, for pragmas, and for hybrids.
.PP
Remembering all this, however, is excessively irritating. So I wrote a module
so I didn't have to anymore. Loading Import::Into creates a global method
\&\f(CW\*(C`import::into\*(C'\fR which you can call on any package to import it into another
package. So now you can simply write:
.PP
.Vb 1
\&  use Import::Into;
\&
\&  $thing\->import::into($target, @import_args);
.Ve
.PP
This works because of how perl resolves method calls \- a call to a simple
method name is resolved against the package of the class or object, so
.PP
.Vb 1
\&  $thing\->method_name(@args);
.Ve
.PP
is roughly equivalent to:
.PP
.Vb 2
\&  my $code_ref = $thing\->can(\*(Aqmethod_name\*(Aq);
\&  $code_ref\->($thing, @args);
.Ve
.PP
while if a \f(CW\*(C`::\*(C'\fR is found, the lookup is made relative to the package name
(i.e. everything before the last \f(CW\*(C`::\*(C'\fR) so
.PP
.Vb 1
\&  $thing\->Package::Name::method_name(@args);
.Ve
.PP
is roughly equivalent to:
.PP
.Vb 2
\&  my $code_ref = Package::Name\->can(\*(Aqmethod_name\*(Aq);
\&  $code_ref\->($thing, @args);
.Ve
.PP
So since Import::Into defines a method \f(CW\*(C`into\*(C'\fR in package \f(CW\*(C`import\*(C'\fR
the syntax reliably calls that.
.PP
For more craziness of this order, have a look at the article I wrote at
http://shadow.cat/blog/matt\-s\-trout/madness\-with\-methods <http://shadow.cat/blog/matt-s-trout/madness-with-methods> which covers
coderef abuse and the \f(CW\*(C`${\e...}\*(C'\fR syntax.
.PP
Final note: You do still need to ensure that you already loaded \f(CW$thing\fR \- if
you're receiving this from a parameter, I recommend using Module::Runtime:
.PP
.Vb 2
\&  use Import::Into;
\&  use Module::Runtime qw(use_module);
\&
\&  use_module($thing)\->import::into($target, @import_args);
.Ve
.PP
And that's it.
.SH "AUTHOR"
.IX Header "AUTHOR"
mst \- Matt S. Trout (cpan:MSTROUT) <mst@shadowcat.co.uk>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
None yet \- maybe this software is perfect! (ahahahahahahahahaha)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2012 the Import::Into \*(L"\s-1AUTHOR\s0\*(R" and \*(L"\s-1CONTRIBUTORS\s0\*(R"
as listed above.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software and may be distributed under the same terms
as perl itself.
